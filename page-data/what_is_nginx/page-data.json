{"componentChunkName":"component---src-templates-post-jsx","path":"/what_is_nginx/","result":{"data":{"site":{"siteMetadata":{"title":"dal.log"}},"markdownRemark":{"id":"9734e30a-b430-5922-919d-f53808a56eb9","excerpt":"이 글은 우테코 달록팀 크루 '리버'가 작성했습니다. 글을 쓰게 된 계기 우테코 레벨3 프로젝트를 진행하면서, HTTPS 통신을 적용하기 위해 NGINX에 대한 이해가 필요했다.\n그래서 NGINX에 대한 이해를 돕기위해 글을 작성하고자 한다. NGINX란? Nginx는 WS(Web Server)의 일종이다. 주로 정적 컨텐츠를 제공하거나 ReversePr…","html":"<blockquote>\n<p>이 글은 우테코 달록팀 크루 '<a href=\"https://github.com/gudonghee2000\">리버</a>'가 작성했습니다.</p>\n</blockquote>\n<h2>글을 쓰게 된 계기</h2>\n<p>우테코 레벨3 프로젝트를 진행하면서, HTTPS 통신을 적용하기 위해 NGINX에 대한 이해가 필요했다.\n그래서 NGINX에 대한 이해를 돕기위해 글을 작성하고자 한다.</p>\n<br>\n<h2>NGINX란?</h2>\n<blockquote>\n<p><em>Nginx는 WS(Web Server)의 일종이다. 주로 정적 컨텐츠를 제공하거나 ReverseProxy, LoadBalancer의 역할을 한다.</em></p>\n</blockquote>\n<br>\n<h2>NGINX의 등장 배경</h2>\n<p>NGINX를 살펴보기전에, 무슨 이유로 NGINX가 등장했는지를 먼저 살펴볼 필요가 있다. 우선 NGINX의 등장배경을 살펴보자.</p>\n<br>\n<p>NGINX 등장이전 Apache가 웹서버로써의 높은 인기를 가졌다.\n잘 사용되던 Apache 웹서버는 어느순간 어떠한 문제를 가져왔다. Apache의 요청처리 메커니즘과 함께 어떠한 문제를 가져왔는지 살펴보자.\n<img src=\"https://velog.velcdn.com/images/gudonghee2000/post/4c31d7af-155b-4998-9ef3-93559914949e/image.JPG\"></p>\n<p>초기의 Apache는 그림과 같이 요청(Request)이 들어올 떄 마다 새로운 Process를 생성하여 네트워크 연결을 하고 요청을 처리했다.(이러한 처리방식을 <code class=\"language-text\">prefork</code>라고 함)</p>\n<p>그런데, 2000년에 접어 들고 인터넷 트래픽이 증가하면서 아파치의 요청 처리방식은 <code class=\"language-text\">C10K</code> 문제를 가져왔다.</p>\n<blockquote>\n<p>C10K 문제란 Connection 10000 Problem의 줄임말로 웹서버가 1만개의 동시 Connection을 처리하기 어렵다는 의미이다.</p>\n</blockquote>\n<p>일단 동시 Connection을 자세히 살펴보자.\n<img src=\"https://velog.velcdn.com/images/gudonghee2000/post/954a297f-e564-43b1-acfa-0f2452854647/image.JPG\"></p>\n<p><code class=\"language-text\">웹서버</code>는 <code class=\"language-text\">클라이언트</code>로 부터 요청이 들어오면 <code class=\"language-text\">Connection</code>을 생성하고 유지한다.\n그리고 그림과 같이 <code class=\"language-text\">클라이언트</code>는 생성된 <code class=\"language-text\">Connection</code>을 통해 또다른 요청을 <code class=\"language-text\">서버</code>에게 전달한다. </p>\n<p>이렇게 <code class=\"language-text\">Connection</code> 하나로 여러 요청을 처리하는 이유는 다음과 같다. 클라이언트와 서버는 <code class=\"language-text\">Connection</code>을 생성하는데 여러가지 절차가 필요하다.\n그래서 매 요청마다 <code class=\"language-text\">Connection</code>을 생성하는것은 비효율적이고 느렸다. </p>\n<p>비효율성을 해결하기 위해 사람들은 이미 만들어진 <code class=\"language-text\">Connection</code>이 있다면 이를 활용하여 요청을 보내고자 하였다.</p>\n<p>이렇게 유지되는 <code class=\"language-text\">Connection</code>들을 <code class=\"language-text\">동시 Connection</code>이라고 한다.</p>\n<blockquote>\n<p>💡 여담으로 HTTP 프로토콜 <code class=\"language-text\">Header</code>부분의 <code class=\"language-text\">Keep-Alive</code>가 바로 <code class=\"language-text\">Connection</code>을 얼마나 유지할 것인지에 대한 통신 규약이다.</p>\n</blockquote>\n<p>이때, Apache 서버는 C10K문제를 가져왔다.\n<img src=\"https://velog.velcdn.com/images/gudonghee2000/post/fa69475a-0326-4652-b1da-616e60164dea/image.JPG\"></p>\n<p>그림과 같이 <code class=\"language-text\">Apache</code>서버는 요청이 들어올 때 마다, <code class=\"language-text\">Process</code>를 생성했는데 요청이 만단위를 넘어가면서 어느순간 부터 요청에 대한 <code class=\"language-text\">Connection</code>을 생성하지 못한것이다. </p>\n<p>이러한 문제를 가져온 원인은 다음과 같았다.</p>\n<ul>\n<li>메모리 부족\nApache서버는 <code class=\"language-text\">Connection</code>이 생성될 때마다 <code class=\"language-text\">Process</code>를 생성해야했는데 동시에 유지해야할 <code class=\"language-text\">Connection</code>이 많아지면서 유지해야할 <code class=\"language-text\">Process</code>가 증가했고 메모리 부족을 발생시켰다.</li>\n<li>CPU 과부하\n또한, 실행중인 <code class=\"language-text\">Process</code>가 많아지면서 CPU는 <code class=\"language-text\">Process</code>를 처리 할 때, <code class=\"language-text\">컨텍스트 스위칭</code>을 굉장히 많이해야했다. 그래서 CPU의 부하가 증가했다.</li>\n</ul>\n<p>결국, 수많은 동시 커넥션을 처리하기엔 Apache의 요청 처리구조는 부적합했다.</p>\n<p>그래서 Apache의 단점을 보완하기 위해 2004년 NGINX가 등장했다.</p>\n<br>\n<h2>NGINX 자세히 알아보기</h2>\n<p>우선, NGINX의 요청 처리 방식을 살펴보자.<img src=\"https://velog.velcdn.com/images/gudonghee2000/post/93b0890b-c015-46d0-9165-5cf6a7b4d9f6/image.JPG\"></p>\n<p>NGINX는 <code class=\"language-text\">MasterProcess</code>를 통해 설정 파일을 읽고 <code class=\"language-text\">WorkerProcess</code>와 같은 자식 <code class=\"language-text\">Process</code> 3종류를 생성한다. (<code class=\"language-text\">cache loader</code>, <code class=\"language-text\">cache manager</code>가 있음)</p>\n<p>그리고 생성된 <code class=\"language-text\">WorkerProcess</code>는 요청이 들어오면 <code class=\"language-text\">Connection</code>을 형성하고 요청을 처리한다.\n요청에 따라서 매번 <code class=\"language-text\">Process</code>를 생성하던 Apache와 달리, NGINX는 <code class=\"language-text\">MasterProcess</code>에 따라 <code class=\"language-text\">WorkerProcess</code>를 생성하고 고정된 개수의 <code class=\"language-text\">WorkerProcess</code> 들이 요청을 처리한다.</p>\n<p>이렇게 고정된 <code class=\"language-text\">Process</code>의 개수로 요청을 처리하기 위해 NGINX는 <code class=\"language-text\">Event-Driven</code> 방식으로 요청을 처리한다.</p>\n<blockquote>\n<p>💡 Event-Driven이란?\nNGINX는 형성된 Connection에 아무런 요청이 없으면 새로운 요청에 대한 Connection을 형성하여 요청을 처리한다.\n또는 이미 만들어진 다른 Connection으로부터 요청을 처리한다.\nNginx에서의 Conneciton 형성, Connection 제거, 새로운 요청 처리를 Event라고 부른다.\n또한, Event를 비동기 방식으로 처리하는 것을 Event-Driven이라고 한다.</p>\n</blockquote>\n<br>\n<p><img src=\"https://velog.velcdn.com/images/gudonghee2000/post/f1b98399-de8f-4f10-bbba-050ca377c4be/image.JPG\"></p>\n<p>NGINX는 그림과 같이 큐형태의 저장소에 Event들을 담아 <code class=\"language-text\">WorkerProcess</code>가 순차적으로 작업을 처리한다.</p>\n<br>\n<h2>NGINX의 Apache의 차이점</h2>\n<p>Apache는 동기방식으로 하나의 <code class=\"language-text\">Connection</code>이 끝날 때 까지 <code class=\"language-text\">Process</code>를 유지했다. </p>\n<p>반면, NGINX는 고정된 <code class=\"language-text\">WokerProcess</code>를 생성하고 <code class=\"language-text\">Event</code>가 발생 할 때마다 요청을 처리하는 비동기 <code class=\"language-text\">Event-Driven</code> 방식을 사용한다는 것이 차이점이다.</p>\n<p>보통 <code class=\"language-text\">WorkerProcess</code>는 CPU의 코어 개수만큼 생성하는것이 일반적이라고 한다. <strong>(이유: 컨텍스트 스위칭 회수를 최소하 하기 위함.)</strong></p>\n<br>\n<h2>NGINX의 장점</h2>\n<p>NGINX는 Apache에 비해 성능 측면에서 두가지 장점이있다.</p>\n<ol>\n<li>처리할수 있는 동시 커넥션 개수가 훨씬 많다.</li>\n<li>동일한 개수의 커넥션 처리 속도가 더 빠르다.</li>\n</ol>\n<p>이러한 장점을 가지고 오는 이유를 마지막으로 정리해보자.</p>\n<ul>\n<li>고정된 <code class=\"language-text\">Process</code> 개수 만을 사용하기에 <code class=\"language-text\">Process</code> 생성 비용이 없다.</li>\n<li>또한, <code class=\"language-text\">Process</code> 개수가 제한되어 CPU의 부담이 줄어든다. (컨텍스트 스위칭이 적어지기 때문)</li>\n<li>비동기 방식이기에 <code class=\"language-text\">Process</code>가 쉬지않고 일을 할 수 있다.</li>\n</ul>\n<br>\n<h2>NGINX 활용 방법</h2>\n<p>도입부에서 이야기햇듯이 NGINX는 정적파일처리, 리버스 프록시, 로드밸런서의 역할로써 WAS의 부담을 줄여주는 역할로 다양하게 활용 할 수 있다.</p>\n<br>\n<h2>마치면서</h2>\n<p>이상 NGINX의 등장 배경과 작동 방식을 살펴보았다.\n많은 크루들이 우아한테크코스 프로젝트를 진행하면서 사용하는 NGINX에 대한 이해에 도움이 되었으면 좋겠다.</p>\n<br>\n<h3>참조</h3>\n<p><a href=\"https://livlikwav.github.io/study/NGINX-inside/\">https://livlikwav.github.io/study/NGINX-inside/</a>\n<a href=\"https://jizard.tistory.com/306\">https://jizard.tistory.com/306</a></p>","frontmatter":{"title":"NGINX 란?","date":"July 30, 2022","update":"July 30, 2022","tags":["WS","NGINX"],"series":null},"fields":{"slug":"/what_is_nginx/","readingTime":{"minutes":8.195}}},"seriesList":{"edges":[{"node":{"id":"a621dc7b-8590-5ec6-9b52-3d9e5182486d","fields":{"slug":"/appearance-background-of-jpa/"},"frontmatter":{"title":"JPA 등장배경"}}},{"node":{"id":"9d2a87b6-2b9c-5b87-b790-3426d17c2d8e","fields":{"slug":"/intellij-final-keyword/"},"frontmatter":{"title":"IntelliJ에서 메소드 추출한 메소드의 파라미터에 final 키워드 자동 추가하기"}}},{"node":{"id":"251e9767-1c92-5cf5-9cef-2c4a42c10df2","fields":{"slug":"/git-branch-strategy/"},"frontmatter":{"title":"달록팀의 git 브랜치 전략을 소개합니다."}}},{"node":{"id":"5090cce3-0c1f-5376-badc-1d25e44c1bd9","fields":{"slug":"/infinite-scroll/"},"frontmatter":{"title":"React에서 무한 스크롤 구현하기"}}},{"node":{"id":"bcb53ba5-0286-5d10-96c2-fdcb88e2cc60","fields":{"slug":"/package-structure/"},"frontmatter":{"title":"달록에 적절한 패키지 구조 고민하기"}}},{"node":{"id":"a7fc89de-f37c-596e-a81d-3d4fe5a795b8","fields":{"slug":"/data-jpa-slice-page/"},"frontmatter":{"title":"Spring Data JPA의 Slice & Page"}}},{"node":{"id":"e1ba92ee-0cf0-50c8-80bd-5da5075df8d1","fields":{"slug":"/data-jpa-auditing/"},"frontmatter":{"title":"Spring Data JPA의 Auditing"}}},{"node":{"id":"3e036508-c916-504e-9e8d-89f69332471e","fields":{"slug":"/separated-interface/"},"frontmatter":{"title":"외부와 의존성 분리하기"}}},{"node":{"id":"cade544a-16ef-58a3-b97c-824986a8395f","fields":{"slug":"/apply-rest-docs/"},"frontmatter":{"title":"MockMvc를 사용한 Spring RestDocs"}}},{"node":{"id":"87649d54-d59e-58a6-afd5-8491eb4113a8","fields":{"slug":"/properties-to-object/"},"frontmatter":{"title":"properties 객체로 다루기"}}},{"node":{"id":"eb380f6d-5a00-5a9e-a916-003fb292cc8a","fields":{"slug":"/test-fixture-constant/"},"frontmatter":{"title":"테스트에서 Entity 객체를 상수로 두면 안 되는 이유"}}},{"node":{"id":"9734e30a-b430-5922-919d-f53808a56eb9","fields":{"slug":"/what_is_nginx/"},"frontmatter":{"title":"NGINX 란?"}}},{"node":{"id":"9ebc6e21-2a76-5d42-be33-c2dae8c849b2","fields":{"slug":"/ssl_protocol/"},"frontmatter":{"title":"SSL을 통한 HTTPS통신 과정"}}},{"node":{"id":"fa5ad595-1f81-5a20-a884-2da69adee3c5","fields":{"slug":"/integration-test-slice-test/"},"frontmatter":{"title":"통합 테스트와 슬라이스 테스트"}}}]},"previous":{"fields":{"slug":"/test-fixture-constant/"},"frontmatter":{"title":"테스트에서 Entity 객체를 상수로 두면 안 되는 이유"}},"next":{"fields":{"slug":"/ssl_protocol/"},"frontmatter":{"title":"SSL을 통한 HTTPS통신 과정"}}},"pageContext":{"id":"9734e30a-b430-5922-919d-f53808a56eb9","series":null,"previousPostId":"eb380f6d-5a00-5a9e-a916-003fb292cc8a","nextPostId":"9ebc6e21-2a76-5d42-be33-c2dae8c849b2"}},"staticQueryHashes":[]}